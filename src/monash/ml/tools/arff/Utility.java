package monash.ml.tools.arff;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Path;
import java.security.SecureRandom;
import java.util.BitSet;
import java.util.function.Predicate;
import java.util.stream.Stream;

import weka.core.Instances;
import weka.core.converters.ArffLoader.ArffReader;

public class Utility {

	// --- --- --- General ARFF utilities

	/** Buffer size for BufferedReader */
	public static final int BUFF_SIZE = 1024 * 1024 * 8;

	/** Capacity for ArffReader */
	public static final int CAPACITY = 100000;

	/** Create an ArffReader over a file represented by a File object. */
	public static final ArffReader getArffReader(File inputFile) throws IOException {
		return new ArffReader(getJavaReader(inputFile), CAPACITY);
	}

	/** Create an ArffReader of a file represented by a Path object */
	public static final ArffReader getArffReader(Path inputFile) throws IOException {
		return getArffReader(inputFile.toFile());
	}
	
	
	/** Create an java Reader over a file represented by a File object. */
	public static final BufferedReader getJavaReader(File inputFile) throws IOException {
		return new BufferedReader(new FileReader(inputFile), BUFF_SIZE);
	}

	/** Create an ArffReader of a file represented by a Path object */
	public static final BufferedReader getJavaReader(Path inputFile) throws IOException {
		return getJavaReader(inputFile.toFile());
	}

	/**
	 * Iterate over a file to count its instance. Read the full file using the
	 * provided reader.
	 */
	public static int countInstance(ArffReader reader) throws IOException {
		Instances structure = reader.getStructure();
		int n = 0;
		while (reader.readInstance(structure) != null) {
			++n;
		}
		return n;
	}

	// --- --- --- Specific utilities

	/**
	 * Randomly partition a dataset represented by a reader in several chunks,
	 * writing them to temporary files. An instance will be in one and only one file
	 * (i.e. the intersection of any two created file is always empty).
	 * 
	 * @throws IOException
	 */
	public static ArffFile[] partitionData(ArffReaderFactory factory, int nbpart, SecureRandom sr)
			throws IOException {
		Predicate<Integer>[] predicates = generateRandomChunkPredicates(factory.getNumData(), nbpart, sr);
		ArffMultiFilteredReader amfr = new ArffMultiFilteredReader(factory, predicates);
		ArffFile[] result = amfr.multiFilteredToFiles("part");
		return result;
	}
	
	/**
	 * Randomly partition a dataset in 2, according to a ratio.
	 * result[0] contains (1-ratio)*factory.getNumData() elements
	 * result[1] contains ratio*factory.getNumData() elements
	 * @throws IOException 
	 */
	public static ArffFile[] splitData(ArffReaderFactory factory, double ratio, SecureRandom sr) throws IOException {
		Predicate<Integer>[] predicates = generateSplitRatioPredicate(factory.getNumData(), ratio, sr);
		ArffMultiFilteredReader amfr = new ArffMultiFilteredReader(factory, predicates);
		ArffFile[] result = amfr.multiFilteredToFiles("split");
		return result;
	}
	
	/**
	 * Spread indices from [0, max[ into n chunks with a probability based on rg.
	 * 
	 * @return an array of length n, containing the randomized set of integers.
	 */
	public static BitSet[] generateRandomChunks(int max, int nchunks, SecureRandom sr) {
		// Step 1) Compute the size of each chunk. Spread the remainder randomly.
		int quotient = max / nchunks;
		int remainder = max % nchunks;
		int[] quotas = new int[nchunks];
		BitSet[] chunks = new BitSet[nchunks];
		// Init the chunks
		for (int i = 0; i < nchunks; ++i) {
			quotas[i] = quotient;
			chunks[i] = new BitSet();
		}
		// Spread the remainder randomly
		for (int i = 0; i < remainder; ++i) {
			int chosenChunk;
			do {
				chosenChunk = sr.nextInt(nchunks);
			} while (quotas[chosenChunk] > quotient);
			quotas[chosenChunk]++;
		}

		// Step 2) Compute the chunks - iterating over the lines' indices
		for (int i = max; i > 0; --i) {
			// drawing a number in [1, i] \subset \mathcal{N}
			int p = sr.nextInt(i) + 1; // from [0, i[ to [1, i] as this is a "quantity", not an index.
			int acc = quotas[0];
			int chunkIdx = 0;
			while (p > acc) { // Go to "next quotas" if p is beyond the current accumulation
				chunkIdx++;
				acc += quotas[chunkIdx];
			}
			// assigning line i to chunk chunkIdx
			chunks[chunkIdx].set(i - 1); // i is in [max, 0[, adjust to [max-1, 0]
			quotas[chunkIdx]--;
		}

		return chunks;
	}

	/**
	 * Create predicate based on the bitsets generated by `generateRandomChunks(int
	 * max, int nchunks, RandomGenerator rg)'
	 */
	public static Predicate<Integer>[] generateRandomChunkPredicates(int max, int nchunks, SecureRandom sr) {

		System.out.println("Generate " + nchunks + " chunks over " + max + " items");

		BitSet[] bitsets = generateRandomChunks(max, nchunks, sr);
		@SuppressWarnings("unchecked") // Because java type system is... what it is.
		Predicate<Integer>[] result = (Predicate<Integer>[]) Stream.of(bitsets).map(b -> new Predicate<Integer>() {
			@Override
			public boolean test(Integer t) {
				return b.get(t);
			}
		}).toArray(Predicate[]::new);

		for (BitSet b : bitsets) {
			System.out.println(b);
		}

		return result;
	}

	/**
	 * Create a bitSet splitting the data in two. The ratio tells us how many '1'
	 * will be in the bitset.
	 */
	public static BitSet generateSplitRatio(int max, double ratio, SecureRandom sr) {
		BitSet res = new BitSet(max);
		int expectedTrue = (int) (max * ratio);
		for (int n = 0; n < expectedTrue; ++n) {
			// Get an index in [0, numData[. Also, get one we did not draw before!
			int idx;
			do {
				idx = sr.nextInt(max);
			} while (res.get(idx));
			res.set(idx);
		}
		return res;
	}

	/**
	 * Create predicate based on the bitset generated by `generateSplitRatio(int
	 * max, double ratio, RandomGenerator rg)' Result: an array of 2 predicates.
	 * array[0]: keep if predicate(idx) == 0 (keep false) array[1]: keep if
	 * predicate(idx) == 1 (keep true)
	 */
	public static Predicate<Integer>[] generateSplitRatioPredicate(int max, double ratio, SecureRandom sr) {

		BitSet bitset = generateSplitRatio(max, ratio, sr);

		Predicate<Integer> keep0 = new Predicate<Integer>() {
			private BitSet set = bitset;

			@Override
			public boolean test(Integer t) {
				return !set.get(t); // keep false
			}
		};

		Predicate<Integer> keep1 = new Predicate<Integer>() {
			private BitSet set = bitset;

			@Override
			public boolean test(Integer t) {
				return set.get(t); // keep true
			}
		};

		@SuppressWarnings("unchecked") // Because the java type system is... what it is.
		Predicate<Integer>[] result = new Predicate[2];

		result[0] = keep0;
		result[1] = keep1;

		return result;
	}

}